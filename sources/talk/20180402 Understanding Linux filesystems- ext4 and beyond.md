
理解 Linux 文件系统：ext4 以及更多文件系统
==========================================

![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/rh_003499_01_linux11x_cc.png?itok=XMDOouJR)

目前的大部分 Linux 文件系统都默认采用 ext4 文件系统, 正如以前的 Linux 发行版默认使用 ext3、ext2 以及更久前的 ext。对于不熟悉 Linux 或文件系统的朋友而言，你可能不清楚 ext4 相对于上一版本 ext3 带来了什么变化。你可能还想知道在一连串关于可替代文件系统例如 btrfs、xfs 和 zfs 的新闻不断被发表下，ext4 是否仍然能得到积极的发展 。
  
在一篇文章中，我们不可能覆盖文件系统的所有方面，但我们尝试让您尽快了解 Linux 默认文件系统的发展历史，包括它的产生以及未来发展。我仔细研究了 维基百科里的各种 ext 文件系统文章、kernel.org‘s 维基百科中关于 ext4 的条目以及结合自己的经验总结文件系统。

### ext 简史

#### MINIX 文件系统

在有 ext之前, 使用的是 MINIX 文件系统。如果你不熟悉 Linux 历史, 那么可以理解为 MINIX 相对于 IBM PC/AT 微型计算机来说是一个非常小的类 Unix 系统。Andrew Tannenbaum 为了教学的目的而开发了它并于 1987 年发布了源代码（印刷版！）。


![](https://opensource.com/sites/default/files/styles/panopoly_image_original/public/u128651/ibm_pc_at.jpg?itok=Tfk3hQYB)


虽然你可以读阅 MINIX 的源代码，但实际上它并不是免费的来源软件（FOSS）。Tannebaum 书的出版商要求你花69美元的许可费来操作 MINIX，而这笔费用包含在书籍的费用中。尽管 如此，在那时来说非常便宜，并且 MINIX 的使用得到迅速发展，很快超过了 Tannebaum 当初使用它来教授操作系统编码的意图。在整个 20 世纪 90 年代，你可以发现 MINIX 安装在世界各个大学里面非常流行。
而此时，年轻的 Lius Torvalds 使用 MINIX 来开发原始 Linux 内核，并于 1991 年首次公布。而后在 1992 年 12 月在 GPL 下发布。

但是等等，这是一篇以*文件系统*为主题的文章不是吗？是的，MINIX 有自己的文件系统，早期的 Linux 版本依赖于它。就像 MINIX 一样，Linux 也可以含糊地被描述为同类的 “玩具” 示例 ———— MINX 文件系统最多能处理
14个字符的文件名，并且只能处理 64MB 的存储空间。到了 1991 年，典型的硬盘尺寸已经达到了 40-140MB。很显然，Linux 需要一个更好的文件系统。

#### ext

当 Linus 开发出刚起步的 Linux 内核时，Rémy Card 开始开发第一个 ext 文件系统。 ext 文件系统在 1992 首次实现并发布 ———— 仅在 Linux 首次发布后的一年! ———— ext 解决了 MINIX 
文件系统中最糟糕的问题。

1992年的 ext 使用在 Linux 内核中的新虚拟文件系统（VFS）抽象层。与之前的 MINIX 文件系统不同的是，ext 可以处理高达 2GB 存储空间并处理 255 个字符的文件名。

但 ext 并没有长时间占统治地位，主要是由于它的原始时间戳（每个文件仅有一个时间戳，而不是今天我们所熟悉的 inode 创建、文件访问和文件修改都有三个独立的标记。）仅仅一年后，ext2 就替代了它。

#### ext2

Rémy 很快就意识到 ext 的局限性，所以一年后他设计出 ext2 替代它。虽然 ext 是源自 "玩具”操作系统，但 ext2 从一开始就被设计为一个商业级文件系统，沿用 BSD 的 Berkeley 文件系统原则。

Ext2 提供了 TB 级的千兆字节和文件系统规格的最大文件大小，使其在 20 世纪 90 年代牢牢地位于大联盟中。很快它被广泛地使用，无论是在 Linux 内核中还是最终在 MINIX 中，且第三方模块使其可以用于 MacOs 和 Windows。

但这里仍然有一些问题需要解决：ext2 文件系统与 20 世纪 90 年代的大多数文件系统一样，如果在将要写入数据到磁盘的时候，系统发生奔溃或断电，则容易发生灾难性的数据损坏。随着时间的推移，由于碎片（单个文件存储在多个位置，物理上其分散在旋转的磁盘上），它们也遭受了严重的性能损失。

尽管存在这些问题，但今天 ext2 还是用在某些特殊的情况下 ———— 最常见的是，作为便携式 USB 拇指驱动器的格式。

#### ext3

1998 年, 在 ext2 被采用后的 6 年后，Stephen Tweedie 宣布他正在致力于改进 ext2。这成了 ext3，并于 2001 年 11 月被 2.4.15 内核版本采用进主线 Linux。


![Packard Bell 计算机][2]

20世纪90年代中期的 Packard Bell 计算机, [Spacekid][3], [CC0][4]

在大部分情况下，Ext2 在 Linux 发行版中做得很好，但像 FAT、FAT32、HFS 和当时的其他文件系统一样—— 在断电时容易发生灾难性的破坏。如果在将数据写入文件系统时候发生断电，则可能会将其留在所谓 *不一致* 的状态 —— 事情只完成一半而另一半未完成。这可能导致大量文件丢失或损坏，这些文件与正在保存的文件无关甚至导致整个文件系统无法卸载。

Ext3 和 20 世纪 90 年代后期的其他文件系统，如微软的 NTFS ，使用*日志*来解决这个问题。 日志是磁盘上的一种特殊分配，其写入是在存储在事务中；如果事务完成写入磁盘，则日志中的数据将提交给文件系统它本身。如果文件在它提交操作前崩溃，则重新启动的系统识别其为未完成的事务而将其进行回滚，就像从未发生过一样。这意味着正在处理的文件可能依然会丢失，但文件系统本身保持一致，且其他所有数据都是安全的。

在使用 ext3 文件系统的 Linux 内核中实现了三个级别的日志记录方式: **journal** , **ordered** , and **writeback**.

  * **Journal** 是最低风险模式，在将数据和元数据提交给文件系统之前将其写入日志。这可以保证正在写入的文件与整个文件系统的一致性，但其显著降低了性能。
  * **Ordered** 是大多数 Linux 发行版默认是模式；ordered 模式将元数据写入日志且直接将数据提交到文件系统。顾名思义，这里的操作顺序是固定的：首先，元数据提交到日志；其次，数据写入文件系统，然后才将日志中关联的元数据更新到文件系统。这确保了在发生奔溃时，与未整写入相关联的元数据仍在日志汇总，且文件系统可以在回滚日志时清理那些不完整的写入事务。在 ordered 模式下，系统崩溃可能导致在崩溃期间文件被主动写入或损坏，但文件系统它本身 —— 以及未被主动写入的文件 —— 确保是安全的。
  * **Writeback** 是第三种 —— 且最不安全的日志模式。在 writeback 模式下,像 ordered 模式一样，元数据是被记录的，但数据不是。与 ordered 模式不同，元数据和数据都可以以任何有意义的顺序写入以获得最佳性能。这可以显著提高性能，但安全性低很多。尽管 wireteback 模式仍然保证文件系统本身的安全性，但在奔溃或之前写入的文件很容易丢失或损坏。


跟之前的 ext2 类似，ext3 使用 16 位内部寻址。这意味着对于有着 4K 块大小的 ext3 在最大规格为 16TiB 的文件系统中可以处理的最大文件大小为 2TiB。

#### ext4

Theodore Ts'o (是当时 ext3 主要开发人员) 在 2006 年宣布了 ext4 ,并于两年后在 2.6.28 内核版本中加入到了 Linux 主线。
Ts’o 将 ext4 描述为一个显著扩展 ext3 的临时技术，但它仍然依赖于旧技术。他预计 ext4 终将会被真正的下一代文件系统所取代。

![](https://opensource.com/sites/default/files/styles/panopoly_image_original/public/u128651/dell_precision_380_workstation.jpeg?itok=3EjYXY2i)

Ext4 在功能上与 Ext3 在功能上非常相似，但大大支持文件系统、提高了对碎片的抵抗力，有更高的性能以及改进了时间戳。

### Ext4 vs ext3

Ext3 和 Ext4 有一些非常明确的差别，在这里集中讨论下。

#### 向后兼容性

Ext4 特地设计为尽可能地向后兼容 ext3。这不仅允许 ext3 文件系统升级到 ext4；也允许 ext4 驱动程序在 ext3 模式下自动挂载 ext3 文件系统，making

因此使它无需单独维护两个代码库。

#### 大文件系统

Ext3 文进系统使用 32 为寻址，将它们限制为 2 个 TiB 文件系统和 16 个 TiB 文件系统（假设一个 4 KiB 块大小；一些 ext3 文件系统使用较小的块大小，因此对其进一步做了限制）。

Ext4 使用48位的内部寻址，理论上可以在文件系统上分配高达 16TiB 的文件，其中最高可达 1000 000 TiB（1EiB）。有些用户区实用程序仍然将 ext4 早期实现限制为 16TiB 文件系统，但截至 2011 年，e2fsprogs 已经直接支持 >16TiB ext4 文件系统。例如，红帽企业 Linux 合同上仅支持最高 50TiB 的 ext4 文件系统，并建议不超过 100TiB 的卷。

#### 分配改进

Ext4 在将存储快写入磁盘之前对存储块的分配方式进行了大量改进，这可以显著提高读写性能。

##### 区段（extent）

区段是一系列连续的物理块大小 (最多达 128 MiB，假设是一个 4KiB块大小），可以一次性保留和寻址。使用区段可以减少给定未见所需的 inode 数量，并显著减少碎片并提高写入大文件时的性能。

##### 多块分配

Ext3 为每一个新分配的块调用一次块分配器。当多个编写器同时打开时，这很容易导致严重的碎片。然而，ext4 使用延迟分配，这允许它合并写入并更好地决定如何为尚未提交的写入分配块。

##### 持续的预分配

在为文件预分配磁盘空间时，大部分文件系统必须在创建时将零写入该文件的块中。Ext4 允许使用 `fallocate()`，它保证了空间的可用性（并试图为它找到连续的空间），而不需要县写入它。
这显著提高了写入和将来读取流和数据库应用程序的写入数据的性能。

##### 延迟分配

这是一个耐人嚼味而有争议性的功能。延迟分配允许 ext4 等待分配将写入数据的实际块，直到它准备好将数据提交到磁盘。（相比之下，即使数据仍然在流入一个写缓存，ext3 也会立即分配块。）

当缓存中的数据累积时，延迟分配允块许文件系统做出分配这些块的更好的选择。不幸的是，当程序员想确保数据完全刷新到磁盘时，它增加了在还没有专门编写调用 ‘fsync（）’方法的程序中的数据丢失的可能性。 

假设一个程序完全重写了一个文件：

`fd=open("file" ,O_TRUNC); write(fd, data); close(fd);`

使用旧的文件系统, `close(fd);` 足以保证 `file` 中的内存刷新到磁盘。即使严格来说，写不是事务性的，但如果文件关闭后发生崩溃，则丢失数据的风险很小。如果写入不成功（由于程序上的错误、磁盘上的错误、断电等），文件的原始版本和交新版本都可能丢失数据或损坏。如果其他进程在写入文件时访问文件，则会看到损坏的版本。
如果其他进程打开文件并且不希望其内容发生更改 —— 如果其他进程在写入文件时访问该文件，则会看到损坏的版本。入股其他进程打开文件并且不希望其内容大声更改 —— 例如，隐射到多个正在运行的程序的共享库 —— 它们可能会崩溃。

为了避免这些问题，一些程序员完全避免使用 `O_TRUNC`。相反，他们可能会写入一个新文件，关闭它，然后将其重命名为旧文件名：

`fd=open("newfile"); write(fd, data); close(fd); rename("newfile", "file");`

在没有延迟分配的文件系统下，这足以避免上面列出的潜在的损坏和崩溃问题：因为`rename()` 是原子操作，所以它不会被崩溃中断；并且运行的程序将引用旧的。现在 `file` 的未链接版本主要有一个打开的文件文件句柄即可。
但是因为 ext4 的延迟分配会导致写入被延迟和重新排序，`rename("newfile","file")` 可以在 `newfile` 的内容实际写入磁盘内容之前执行，这打开了并行进行再次获得 `file` 坏版本的问题。


为了缓解这种情况，Linux 内核（自版本 2.6.30 ）尝试检测这些常见代码情况并强制立即分配。这减少但不能防止数据丢失的可能性 —— 并且它对新文件没有任何帮助。如果你是一位开发人员，请注意：

保证数据立即写入磁盘的方法是正确调用 `fsync()` 。

#### 无限制的子目录

Ext3 仅限于 32000 个子目录；ext4 允许 w 无限数量的子目录。从 2.6.23内核版本开始，ext4 使用 HTree 索引来减少大量子目录的性能损失。

#### 日志校验

Ext3 没有对日志进行校验，这给内核直接控制之外的磁盘或控制器设备带来了自己的缓存问题。如果控制器或具有子集对缓存的磁盘确实无序写入，则可能会破坏 ext3 的日记事务顺序，
从而可能破坏在崩溃期间（或之前一段时间）写入的文件。
 
理论上，这个问题可以使用 write barriers—— 在安装文件系统时，你在挂载选项设置 `barrier=1` ，然后将设备 `fsync` 一直向下调用直到 metal。通过实践，可以发现存储设备和控制器经常不遵守 write barriers —— 提高性能（和 benchmarks，跟竞争对手比较），但
增加了本应该防止数据损坏的可能性。

对日志进行校验和允许文件系统奔溃后意识到其某些条目在第一次安装时无效或无序。因此，这避免了即使部分存储设备不存在 barriers ，也会回滚部分或无序日志条目和进一步损坏的文件系统的错误。rolling back partial or out-of-order journal entries and further damaging the filesystem—even if the storage devices lie and don't honor barriers.

#### 快速文件系统检查

在 ext3 下，整个文件系统 —— 包括已删除或空文件 —— 在 `fsck` 被调用时需要检查。相比之下，ext4 标记了未分配块和 inode 表的小部分，从而允许 `fsck` 完全跳过它们。
这大大减少了在大多数文件系统上运行 `fsck` 的时间，并从内核 2.6.24 开始实现。

#### 改进的时间戳

Ext3提供粒度为一秒的时间戳。虽然足以满足大多数用途，但任务关键型应用程序经常需要更严格的时间控制。Ext4 通过提供纳秒级的时间戳，使其可用于那些企业，科学以及任务关键型的应用程序。

Ext3文件系统也没有提供足够的位来存储 2038 年 1 月 18 日以后的日期。Ext4 在这里增加了两位，将 [the Unix epoch][5] 扩展了 408 年。如果你在公元 2446 年读到这篇文章，
你有希望已经转移到一个更好的文件系统 - 但是如果你还在测量 UTC 00:00，1970年1月1日以来的时间，它会让我非常非常高兴。

#### 在线碎片整理

ext2 和 ext3 都不直接支持在线碎片整理 —— 即在挂载时会对文件系统进行碎片整理。Ext2 有一个包含的实用程序，**e2defrag**，它的名字暗示 —— 但它需要在文件系统未挂载时脱机运行。
（显然，这对于根文件系统来说非常有问题。）在 ext3 中的情况甚至更糟糕 - 虽然 ext3 比 ext2 更不容易受到严重碎片的影响，但 ext3 文件系统运行 **e2defrag** 可能会导致灾难性损坏
和数据丢失。

尽管 ext3 最初被认为“不受碎片影响”，但对同一文件（例如 BitTorrent）采用大规模并行写入过程的过程清楚地表明情况并非完全如此。一些用户空间攻击和解决方法，例如 [Shake][6]，
以这种或那种方式解决了这个问题 —— 但它们比真正的、文件系统感知的、内核级碎片整理过程更慢并且在各方面都不太令人满意。

Ext4通过 **e4defrag** 解决了这个问题，且是一个在线、内核模式、文件系统感知、块和范围级别的碎片整理实用程序。

### 正在进行的ext4开发

正如 Monty Python （ plague victim？？）曾经说过的那样，Ext4 “还没完全死！” 虽然它的[主要开发人员][7]认为它只是一个真正的[下一代文件系统][8]的权宜之计，但是在一段时间内，没有任何可能的候选人准备好（由于技术或许可问题）部署为根文件系统。

在未来的 ext4 版本中仍然有一些关键功能，包括元数据校验和、一流的配额支持和大型分配块。

#### 元数据校验和

由于 ext4 具有冗余超级块，因此为文件系统校验其中的元数据提供了一种方法，可以自行确定主超级块是否已损坏并需要使用备用块。可以在没有校验和的情况下，从损坏的超级块恢复 —— 但是用户首先需要意识到它已损坏，然后尝试使用备用方法手动挂载文件系统。由于在某些情况下，使用损坏的主超级块安装文件系统读写
可能会造成进一步的损坏，即使是经验丰富的用户也无法避免，这也不是一个完美的解决方案！

与 btrfs 或 zfs 等下一代文件系统提供的极其强大的每块校验和相比，ext4 的元数据校验和功能非常弱。但它总比没有好。虽然校验和所有的事情都听起来很简单！—— 事实上，将校验和连接到文件系统有一些重大的挑战； 请参阅[设计文档][9]了解详细信息。

#### 一流的配额支持

等等，配额？！从 ext2 出现的那条开始我们就有了这些！是的，但他们一直都是事后的想法，而且他们总是有点傻逼。这里可能不值得详细介绍，
但[设计文档][10]列出了配额将从用户空间移动到内核中的方式，并且能够更加正确和高效地执行。

#### 大分配块
随着时间的推移，那些讨厌的存储系统不断变得越来越大。由于一些固态硬盘已经使用 8K 硬件模块，因此 ext4 对 4K 模块的当前限制越来越受到限制。
较大的存储块可以显着减少碎片并提高性能，代价是增加“松弛”空间（当您只需要块的一部分来存储文件或文件的最后一块时留下的空间）。

您可以在[设计文档][11]中查看详细说明。

### ext4的实际限制

Ext4是一个健壮，稳定的文件系统。它是大多数人应该在 2018 年用作根文件系统的东西，但它无法处理所有内容。让我们简单地谈谈你不应该期待的一些事情 —— 现在或可能在未来。

虽然 ext4 可以处理高达 1 EiB 相当于 1,000,000 TiB 的数据，但你真的、真的不应该尝试这样做。除了仅仅能够记住更多块的地址之外，还存在规模上的问题
并且现在 ext4 不会处理（并且可能永远不会）超过 50 —— 100TiB 的数据。

Ext4 也不足以保证数据的完整性。随着日志记录的重大进展又回到了前 3 天，它并未涵盖数据损坏的许多常见原因。如果数据已经在磁盘上被[破坏][12]——由于故障硬件，
宇宙射线的影响（是的，真的），或者数据随时间的简单降级 —— ext4无法检测或修复这种损坏。

在最后两个项目的基础上，ext4 只是一个纯文件系统，而不是存储卷管理器。这意味着，即使你有多个磁盘 —— 因此也就是奇偶校验或冗余，理论上你可以恢复损坏的数据从 —— ext4 
但无法知道使用它是否对你有利。虽然理论上可以在离散层中分离文件系统和存储卷管理系统而不会丢失自动损坏检测和修复功能，但这不是当前存储系统的设计方式，
并且它将给新设计带来重大挑战。

### 备用文件系统
在我们开始之前，提醒一句：要非常小心这是没有内置任何备用的文件系统，并直接支持为您分配的主线内核的一部分！

即使文件系统是安全的，如果在内核升级期间出现问题，使用它作为根文件系统也是绝对可怕的。如果你没有充分的想法通过一个 chroot 去使用介质引导，耐心地操作内核模块和 grub 配置，
和 DKMS...不要去预订系统的根文件系统很重要。

可能有充分的理由使用您的发行版不直接支持的文件系统 —— 但如果您这样做，我强烈建议您在系统启动并可用后再安装它。
（例如，您可能有一个 ext4 根文件系统，但是将大部分数据存储在 zfs 或 btrfs 池中。）

#### XFS

XFS 与 非 ext 文件系统在Linux下的主线一样。它是一个 64 位的日志文件系统，自 2001 年以来内置于 Linux 内核中，为大型文件系统和高度并发性提供了高性能
（即，大量的进程都会立即写入文件系统）。

从RHEL 7开始，XFS 成为 Red Hat Enterprise Linux 的默认文件系统。对于家庭或小型企业用户来说，它仍然有一些缺点 —— 最值得注意的是，重新调整现有 XFS 文件系统
是一件非常痛苦的事情，不如创建另一个并复制数据更有意义。

虽然 XFS 是稳定且是高性能的，但它和 ext4 之间没有足够的具体的最终用途差异来推荐它在非默认值的任何地方使用（例如，RHEL7），除非它解决了对 ext4 的特定问题，例如> 50 TiB容量的文件系统。

XFS 在任何方面都不是 ZFS，btrfs 甚至 WAFL（专有 SAN 文件系统）的“下一代”文件系统。就像 ext4 一样，它应该被视为一种更好的方式的权宜之计。

#### ZFS

ZFS 由 Sun Microsystems 开发，以 zettabyte 命名 —— 相当于 1 万亿 GB —— 因为它理论上可以解决大型存储系统。

作为真正的下一代文件系统，ZFS 提供卷管理（能够在单个文件系统中处理多个单独的存储设备），块级加密校验和（允许以极高的准确率检测数据损坏），
[自动损坏修复][12]（其中冗余或奇偶校验存储可用），[快速异步增量复制][13]，内联压缩等，[还有更多][14]。

从 Linux 用户的角度来看，ZFS 的最大问题是许可证问题。ZFS 获得了 CDDL 许可证，这是一种与 GPL 冲突的半许可许可证。关于在 Linux 内核中使用 ZFS 的意义存在很多争议，
其争议范围从“它是 GPL 违规”到“它是 CDDL 违规”到“它完全没问题，它还没有在法庭上进行过测试。 “ 最值得注意的是，自2016年以来，Canonical 已将 ZFS 代码内联
在其默认内核中，而且目前尚无法律挑战。

此时，即使我作为一个非常狂热于 ZFS 的用户，我也不建议将 ZFS 作为 Linux的 root 文件系统。如果你想在 Linux 上利用 ZFS 的优势，在 ext4 上设置一个小的根文件系统，
然后将 ZFS 放在你剩余的存储上，把数据，应用程序以及你喜欢的东西放在它上面 —— 但在 ext4 上保持 root，直到你的发行版明显支持 zfs 根目录。

#### BTRFS

Btrfs 是 B-Tree Filesystem 的简称，通常发音为 “butter” —— 由 Chris Mason 于 2007 年在 Oracle 任职期间宣布。BTRFS 旨在跟 ZFS 有大部分相同的目标，
提供多种设备管理，每块校验、异步复制、直列压缩等，[还有更多][8]。

截至 2018 年，btrfs 相当稳定，可用作标准的单磁盘文件系统，但可能不应该依赖于卷管理器。与许多常见用例中的 ext4，XFS 或 ZFS 相比，它存在严重的性能问题，
其下一代功能 —— 复制，多磁盘拓扑和快照管理 —— 可能非常多，其结果可能是从灾难性地性能降低到实际数据的丢失。

btrfs 的持续状态是有争议的; SUSE Enterprise Linux 在 2015 年采用它作为默认文件系统，而 Red Hat 宣布它将不再支持从 2017 年开始使用 RHEL 7.4 的 btrfs。
可能值得注意的是，生产，支持的 btrfs 部署将其用作单磁盘文件系统，而不是作为一个多磁盘卷管理器 —— a la ZFS —— 甚至 Synology 在它的存储设备使用 BTRFS，
但是它在传统 Linux 内核 RAID（mdraid）之上分层来管理磁盘。

--------------------------------------------------------------------------------

via: https://opensource.com/article/18/4/ext4-filesystem

作者：[Jim Salter][a]
译者：[HardworkFish](https://github.com/HardworkFish)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]:https://opensource.com/users/jim-salter
[1]:https://opensource.com/file/391546
[2]:https://opensource.com/sites/default/files/styles/panopoly_image_original/public/u128651/packard_bell_pc.jpg?itok=VI8dzcwp (Packard Bell computer)
[3]:https://commons.wikimedia.org/wiki/File:Old_packard_bell_pc.jpg
[4]:https://creativecommons.org/publicdomain/zero/1.0/deed.en
[5]:https://en.wikipedia.org/wiki/Unix_time
[6]:https://vleu.net/shake/
[7]:http://www.linux-mag.com/id/7272/
[8]:https://arstechnica.com/information-technology/2014/01/bitrot-and-atomic-cows-inside-next-gen-filesystems/
[9]:https://ext4.wiki.kernel.org/index.php/Ext4_Metadata_Checksums
[10]:https://ext4.wiki.kernel.org/index.php/Design_For_1st_Class_Quota_in_Ext4
[11]:https://ext4.wiki.kernel.org/index.php/Design_for_Large_Allocation_Blocks
[12]:https://en.wikipedia.org/wiki/Data_degradation#Visual_example_of_data_degradation
[13]:https://arstechnica.com/information-technology/2015/12/rsync-net-zfs-replication-to-the-cloud-is-finally-here-and-its-fast/
[14]:https://arstechnica.com/information-technology/2014/02/ars-walkthrough-using-the-zfs-next-gen-filesystem-on-linux/
