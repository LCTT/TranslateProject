IBM 029 型打孔机
======

我知道这很学院派，可一行超过 80 个字符的代码还是让我抓狂。我也在网上见过不少人认为即使在现代的视网膜屏幕下也应当采用行长度为 80 个字符的标准，可他们都不理解我对破坏这一标准的怒火，就算多 1 个字符也不行。

在这一标准的黄金时期，一行代码的长度几乎不会超过 80 个字符的限制。在那时，这一限制是物理的，没有第 81 列用于存放第 81 个字符。每一个试图把函数名起的又长又臭的程序员都会在短暂的愉悦后迎来更多的麻烦，而这仅仅是因为没有足够的空间放下整个函数的声明。

这一黄金时期也是<ruby>打孔卡<rt>punch card</rt></ruby>编程时期。在 20 世纪 60 年代，IBM 打孔卡设立了标准，这个标准就是打孔卡的宽度为 80 列。这个 80 列标准在后来的电传打字机和哑终端时期得以延续，并逐渐成为操作系统中隐藏的细节。时至今日，即使我们用上了更大、更好的屏幕，偏向于使用更长的标识符而不是类似 `iswcntrl()` 这样令人难以猜测的函数名，可当你打开新的终端模拟器窗口时，默认的宽度依然是 80 个字符。

从 Quora 上的很多问题中可以发现，很多人并不能想象如何使用打孔卡给计算机编程。我承认，在很长的一段时间里我也不能理解打孔卡编程是如何工作的，因为这让我想到就像劳工一样不停的给这些打孔卡打孔。当然，这是一个误解，程序员不需要亲自给打孔卡打孔，就像是火车调度员不用亲自扳道岔。程序员们有<ruby>打孔机<rt>card punch machines</rt></ruby>（也被称为<ruby>键控打孔机<rt>key punches</rt></ruby>），这让他们可以使用打字机式的键盘给打孔卡打孔。这样的设备在 19 世纪 90 年代时就已经不是什么新技术了。

那时，最为广泛使用的打孔机之一便是 IBM 029 型打孔机。就算在今天，它也许是最棒的打孔机。

![][1]

IBM 029 型打孔机在 1964 年作为 IBM 的 System/360 大型电脑的配件发售的。System/360 是计算系统与外设所组成的一个系列，在 20 世纪 60 年代晚期，它几乎垄断了整个大型计算机市场。就像其它 System/360 外设一样，029 型打孔机也是个大块头。那时，计算机和家具的界限还很模糊，但 029 型打孔机可不是那种会占领你的整张桌子的机器。它改进自 026 型打孔机，增加了新的字符支持，如括号，总体上也更加安静。与前辈 026 型所展出 20 世纪 40 年代的圆形按钮与工业化的样貌相比，029 型的按键方正扁平、功能按键还有酷炫的蓝色高亮提示。它的另一个重要买点是它能够在<ruby>数字区<rt>numeric field</rt></ruby>左侧自动的填充 0 ，这证明了 JavaScript 程序员不是第一批懒得自己做<ruby>左填充<rt>left-padding</rt></ruby>的程序员。（LCTT 译注：这项功能需要额外的 4 张 <ruby>[标准模块系统卡](https://en.wikipedia.org/wiki/IBM_Standard_Modular_System)<rt>SMS card</rt></ruby>才能使用。例如设置数字区域长度为 6 列时，操作员只需要输入 73 ，打孔机会自动填充起始位置上的 4 个 0 ，故最终输出 000073。[更多信息](https://en.wikipedia.org/wiki/Keypunch#IBM_029_Card_Punch)）

等等！你说的是 IBM 在 1964 年发布了全新的打孔机？你知道那张在贝尔实验室拍摄的 Unix 之父正在使用电传打字机的照片吗？那是哪一年的来着？1970？打孔机不是应该在 20 世纪 60 年代中期到晚期时就过时了吗？是的，你也许会奇怪，为什么直到 1984 年，IBM 的产品目录中还会出现 029 型打孔机的身影 [^1]。事实上，直到 20 世纪 70 年代，大多数程序员仍然在使用打孔卡编程。其实二战期间就已经有人在用电传打字机了，可那时并没能普及。客观的讲，电传打字机几乎和打孔卡一样古老。也许和你想象的恰恰相反，并不是电传打字机本身限制了它的普及，而是计算时间。人们拒绝使用电传打字机的原因是，它是可交互的，它和计算机使用<ruby>“在线”的传输方式<rt>"online" mode of communication</rt></ruby>。在以 Unix 为代表的分时操作系统被发明前，你和电脑的交互会被任何人的使用而打断，而这一点延迟通常意味着几千美元的损失。所以程序员们普遍选择离线地使用打孔机编程，再将打孔卡放入大型计算机中，作为<ruby>批任务<rt>batch job</rt></ruby>执行。在那时，还没有即廉价又可靠的存储设备，可打孔卡的廉价优势已经足够让它成为那时最流行的数据存储方式了。那时的程序是书架上一摞打孔卡而不是硬盘里的一堆文件。

那么实际使用 IBM 029 型打孔机是个什么样子呢？这很难向没有实际看过打孔卡的人解释。一张打孔卡通常有 12 行 80 列。打孔卡下面是从 1 到 9 的<ruby>数字行<rt>digit rows</rt></ruby>，打孔卡上的每一列都有这些行所对应的数字。最上面的三行是<ruby>空间行<rt>"zone" rows</rt></ruby>，通常由两行空白行和一行 0 行组成。第 12 行是打孔卡最顶部的行，接下来是 11 行，随后是从数字 0 到 9 所在的行。这个有点让人感到困惑的顺序的原因是打孔卡的上边缘被称为<ruby>12 边<rt>12 edge</rt></ruby>、下边缘被称为 <ruby>9 边<rt>9 edge</rt></ruby>。那时，为了让打孔卡便于整理，常常会剪去打孔卡的一个角。

![][2]

（LCTT 译注：可参考[EBCDIC 编码](https://zh.wikipedia.org/wiki/EBCDIC)）

在打孔卡发明之初，孔洞的形状是圆形的，但是 IBM 最终意识到如果使用窄长方形作为孔洞，一张卡就可以放下更多的列了。每一列中孔洞的不同组合就可以表达不同的字符。像 029 型这样的拥有人性化设计的打孔机除了完成本质的打孔任务外，还会在打孔卡最上方打印出每一列所对应的字符。输入是数字就在对应的数字行上打孔。输入的是字母或符号就用一个在空间列的孔和一或俩个在数字列的孔的组合表示，例如字母 A 就用一个在第 12 空间行的空和一个数字 1 所在行的孔表示。这是一种顺序编码，在第一台打孔机被发明后，也叫 Hollerith 编码。这种编码只能表示相对较小的一套字符集，小写字母就没有包含在这套字符集中。如今一些聪明的工程师可能想知道为什么打卡不干脆使用二进制编码 —— 毕竟，有 12 行，你可以编码超过 4000 个字符。 使用 Hollerith 编码是因为它确保在单个列中出现不超过三个孔。这保留了卡的结构强度。二进制编码会带来太多的孔，会因为孔洞过于密集而断裂。

打孔卡也有不同。在 20 世纪 60 年代，80 列虽然是标准，但表达的方式不一定相同。基础打孔卡是无标注的，但用于 COBOL 编程的打孔卡会把最后的 8 列保留，供标识数保存使用。这一标识数可以在打孔卡被打乱 (例如一叠打孔卡掉在地上了) 后用于自动排序。此外，第 7 列被用于表示本张打孔卡上的是否与上一张打孔卡一起构成一条语句。也就是说当你真的对 80 字符的限制感到绝望的时候，还可以用两张卡甚至更多的卡拼接成一条长语句。用于 FORTRAN 编程的打孔卡和 COBOL 打孔卡类似，但是定义的列不同。大学里使用的打孔卡通常会由其计算机中心加上水印，其它的设计则会在如 [1976 年美国独立 200 周年][3] 的特殊场合才会加入。

最终，这些打孔卡都要被计算机读取和计算。IBM 出售的 System/360 大型计算机的外设 IBM 2540 可以以每分钟 1000 张打孔卡的速度读取这些卡片[^2] 。IBM 2540 使用电刷扫过每张打孔卡，电刷通过孔洞就可以接触到卡片后面的金属板完成一次读取。一旦读取完毕，System/360 大型计算机就会把每张打孔卡上的数据使用一种定长的 8 位编码保存，这种编码是<ruby>扩增二进式十进交换码<rt>Extended Binary Coded Decimal Interchange Code</rt></ruby>，简写为 EBCDIC 编码。它是一种二进制编码，可以追溯自早期打孔卡所使用的 BCDIDC 编码 —— 其 6 位编码使用低 4 位表示数字行，高 2 位表示空间行。程序员们在打孔卡上编写完程序后，会把卡片们交给计算机操作员，操作员们会把这些卡片放入 IBM 2540 ，再把打印结果交给程序员。那时的程序员大多都没有见过计算机长什么样。

程序员们真正能见到的是很多打孔机。029 型打孔机虽然不是计算机，但这并不意味着它不是一台复杂的机器。看看这个由<ruby>密歇根大学<rt>University of Michigan</rt></ruby>计算机中心在 1967 年制作的[教学视频][4]，你就能更好的理解使用一台 029 型打孔机是什么情形了。我会尽可能在这里总结这段视频，但如果你不去亲自看看的话，你会错过许多惊奇和感叹。

029 型打孔机的结构围绕着一个打孔卡穿过机器的 U 形轨道开始。使用打孔机时，右手边也就是 U 形轨道的右侧顶部是<ruby>进卡卡槽<rt>hopper</rt></ruby>，使用前通常在里面放入一叠未使用的打孔卡。虽然 029 型打孔机主要使用 80 列打孔卡，但在需要的情况下也可以使用更小号的打孔卡。在打孔机的使用过程中，打孔卡离开轨道右上端的进卡卡槽，顺着 U 形轨道移动并最终进入左上端的<ruby>出卡卡槽<rt>stacker</rt></ruby>。这一流程可以保证出卡卡槽中的打孔卡按打孔时的先后顺序排列。

029 型打孔机的开关在桌面下膝盖高度的位置。在开机后，连按两次 “<ruby>装入<rt>FEED</rt></ruby>” 键让机器自动将打孔卡从进卡卡槽中取出并移动到机器内。 U 形轨道的底部是打孔机的核心区域，它由三个部分组成：右侧是等待区，中间是打孔操作区，左侧是阅读区。连按两次 “装入” 键，机器就会把一张打孔卡装入打孔机的打孔操作区，另一张打孔卡进入等待区。在打孔操作区上方有一个列数指示器来显示当前打孔所在的列的位置。这时，每按下一个按键，机器就会在打孔卡对应的位置打孔并在卡片的顶部打印按键对应的字符，随后将打孔卡向左移动一列。如果一张卡片的 80 列全部被打上了数据，这张卡片会被打孔操作区自动释放并进入阅读区，同时，一张新的打孔卡会被装入打孔操作区。如果没有打完全部的 80 列，可以使用 “<ruby>释放<rt>REL</rt></ruby>” 键完成上面的操作。

在打孔卡上打印对应的字符这一设计让人很容易分辨出错误。但就像密歇根大学的视频中警告的那样，打孔卡上修正一个错误可不像擦掉一个打印的字符然后再写上一个新的那样容易，因为计算机只会根据卡片上的孔来读取信息。因为被打出的孔不能被<ruby>复原<rt>unpunched</rt></ruby>，所以并不能直接退回一列然后再打上一个新的字符。打出更多的孔也只能让这一列的组合变成一个无效字符。IBM 029 型打孔机上虽然有一个可以让打孔卡回退一列的退格按键，但这个按键被放置在机器上而非在键盘上。这样的设计也许是为了阻止这个按键的使用，因为实际上很少有用户需要这个功能。

实际上，只有废弃错误的打孔卡再在新的打孔卡上重新打孔这一种修正错误的方式。这就是阅读区的用武之处了。当你发现打孔卡上的第 68 列出错时，你需要在新的打孔卡上小心的给前 67 列重新打孔，然后给第 68 列打上正确的字母。另一种操作方式是把带有错误信息的打孔卡放在阅读区，同时在打孔操作区载入一张新的打孔卡，然后按下 “<ruby>重复<rt>DUP</rt></ruby>” 按键直到列数指示器显示 68 列。这时按下正确的字符来修正错误。阅读区和重复按键使得 029 型打孔机很容易复制打孔卡上的内容。当然，这一功能的使用可能有各种各样的原因，但改错是最常见的。

（LCTT 译注：有一种说法是“补丁”这个用于对已经发布的软件进行修复的术语来源于对打孔纸带或打孔卡上打错的孔贴上补丁的做法。可能对于长长的一卷打孔纸带来说，由于个别字母的错误而整个废弃成本过高，会采用“补丁”的方式；而对于这种单张式的打孔卡来说，重新打印一张正确的更为方便。）

“重复”按键允许 029 型打孔机的操作员手动调用重复的函数。但是 029 型打孔机还可以设置为自动重复。当用于记录数据而不是编程时，这项功能十分有效。举个例子，当用打孔卡来记录大学生的信息时，每张卡片上都需要输入学生的宿舍楼的名字，如果发现所输入信息的学生都在同一栋楼，就可以使用 029 型打孔机的自动重复功能来完成宿舍楼名称的填写。

像这样的自动化操作可以通过<ruby>程序鼓<rt>program drum</rt></ruby>编程到 029 型打孔机里面。程序鼓就安装在打孔操作区上方的 U 形轨道中间部分的右上角。通过在打孔卡上写下程序，然后把打孔卡装入程序鼓中，就完成了一次给 029 型打孔机的编程任务。用户可以通过这种方式对打孔卡的每一列都按需要定义不同的自动化操作。029 型打孔机允许指定某些列重复上一张打孔卡相同位置的字符，这就是它能更快的输入学生信息的理由。它还允许指定某些列只能输入数字或者字母，指定特定的列为空或者到某一列时就直接跳过一整张打孔卡。编程鼓使它在打孔特定列有特殊含义的固定模式卡片时很容易。密歇根大学制作的另一个[进阶教学视频][5]包括了给 029 型打孔机编程的过程，如果你已经掌握了它的基础操作，就快去看看吧。

这会儿，无论你是否看了密歇根大学制作的视频，都会感叹打孔机的操作之简便。虽然修正错误的过程很乏味，但除此之外，操作一台打孔机并不像想象的那样复杂。我甚至可以想象打孔卡之间的无缝切换让 COBOL 和 FORTRAN 程序员忘记了他们的程序是打在不同的打孔卡上而不是写在一个连续的文本文件内。另一方面，思考一下打孔机是如何影响编程语言的发展也是很有趣的，虽然它仅仅是一台输入设备。结构化编程最终会出现并鼓励程序员把整个代码块视为一个整体，但可以想象打孔卡程序员们强调每一行的作用且难以认同结构化编程的场景。同时你能够理解他们为什么不把代码块闭合所使用的括号放在单独的一行，只是因为这样会浪费打孔卡。

现在，虽然没有人再使用打孔卡编程了，每个程序员都该试试[这个][6]，哪怕一次也好。或许你因此能够更好的理解 COBOL 和 FORTRAN 的历史，或许你就能体会到为什么每个人把 80 个字符作为长度限制的标注。

喜欢吗？这里每两周都会发表一篇这样的文章。请在推特上关注我们 [@TwoBitHistory][7] 或者订阅我们的 [RSS][8]，这样你就能在第一时间收到新文章的通知。

[^1]: “IBM 29 Card Punch,” IBM Archives, accessed June 23, 2018, https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html. 
[^2]: IBM, IBM 2540 Component Description and Operation Procedures (Rochester, MN: IBM Product Publications, 1965), September 06, 2009, accessed June 23, 2018, http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf. 

--------------------------------------------------------------------------------

via: https://twobithistory.org/2018/06/23/ibm-029-card-punch.html

作者：[Two-Bit History][a]
选题：[lujun9972][b]
译者：[wwhio](https://github.com/wwhio)
校对：[wxy](https://github.com/wxy)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]: https://twobithistory.org
[b]: https://github.com/lujun9972
[1]: https://twobithistory.org/images/ibm029_front.jpg
[2]: https://twobithistory.org/images/card.png
[3]: http://www.jkmscott.net/data/Punched%20card%20013.jpg
[4]: https://www.youtube.com/watch?v=kaQmAybWn-w
[5]: https://www.youtube.com/watch?v=SWD1PwNxpoU
[6]: http://www.masswerk.at/keypunch/
[7]: https://twitter.com/TwoBitHistory
[8]: https://twobithistory.org/feed.xml
