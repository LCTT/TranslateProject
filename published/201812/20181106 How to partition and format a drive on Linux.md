如何在 Linux 上对驱动器进行分区和格式化
======

> 这里有所有你想知道的关于设置存储器而又不敢问的一切。

![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/hard_drives.png?itok=gOJt8RV3)

在大多数的计算机系统上，Linux 或者是其它，当你插入一个 USB 设备时，你会注意到一个提示驱动器存在的警告。如果该驱动器已经按你想要的进行分区和格式化，你只需要你的计算机在文件管理器或桌面上的某个地方列出驱动器。这是一个简单的要求，而且通常计算机都能满足。

然而，有时候，驱动器并没有按你想要的方式进行格式化。对于这些，你必须知道如何查找准备连接到您计算机上的存储设备。

### 什么是块设备？

硬盘驱动器通常被称为“块设备”，因为硬盘驱动器以固定大小的块进行读写。这就可以区分硬盘驱动器和其它可能插入到您计算机的一些设备，如打印机、游戏手柄、麦克风，或相机。一个简单的方法用来列出连接到你 Linux 系统上的块设备就是使用 `lsblk` （list block devices）命令：

```
NAME                  MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT
sda                    8:0    0 238.5G  0 disk  
├─sda1                 8:1    0     1G  0 part  /boot
└─sda2                 8:2    0 237.5G  0 part  
  └─luks-e2bb...e9f8 253:0    0 237.5G  0 crypt 
        ├─fedora-root    253:1    0    50G  0 lvm   /
        ├─fedora-swap    253:2    0   5.8G  0 lvm   [SWAP]
        └─fedora-home    253:3    0 181.7G  0 lvm   /home
sdb                   8:16    1  14.6G  0 disk  
└─sdb1                8:17    1  14.6G  0 part
```

最左列是设备标识符，每个都是以 `sd` 开头，并以一个字母结尾，字母从 `a` 开始。每个块设备上的分区分配一个数字，从 `1` 开始。例如，第一个设备上的第二个分区用 `sda2` 表示。如果你不确定到底是哪个分区，那也不要紧，只需接着往下读。

`lsblk` 命令是无损的，仅仅用于检测，所以你可以放心的使用而不用担心破坏你驱动器上的数据。

### 使用 dmesg 进行测试

如果你有疑问，你可以通过在 `dmesg` 命令的最后几行查看驱动器的卷标，这个命令显示了操作系统最近的日志（比如说插入或移除一个驱动器）。一句话，如果你想确认你插入的设备是不是 `/dev/sdc` ，那么，把设备插到你的计算机上，然后运行这个 `dmesg` 命令：

```
$ sudo dmesg | tail
```

显示中列出的最新的驱动器就是你刚刚插入的那个。如果你拔掉它，并再运行这个命令一次，你可以看到，这个设备已经被移除。如果你再插上它再运行命令，这个设备又会出现在那里。换句话说，你可以监控内核对驱动器的识别。

### 理解文件系统

如果你只需要设备卷标，那么你的工作就完成了。但是如果你的目的是想创建一个可用的驱动器，那你还必须给这个驱动器做一个文件系统。

如果你还不知道什么是文件系统，那么通过了解当没有文件系统时会发生什么可能会更容易理解这个概念。如果你有多余的设备驱动器，并且上面没有什么重要的数据资料，你可以跟着做一下下面的这个实验。否则，请不要尝试，因为根据其设计目的，这个肯定会删除您的资料。

当一个驱动器没有文件系统时也是可以使用的。一旦你已经肯定，正确识别了一个驱动器，并且已经确定上面没有任何重要的资料，那就可以把它插到你的计算机上 —— 但是不要挂载它，如果它被自动挂载上了，那就请手动卸载掉它。

```
$ su -
# umount /dev/sdx{,1}
```

为了防止灾难性的复制 —— 粘贴错误，下面的例子将使用不太可能出现的 `sdx` 来作为驱动器的卷标。

现在，这个驱动器已经被卸载了，尝试使用下面的命令：

```
# echo 'hello world' > /dev/sdx
```

你已经可以将数据写入到块设备中，而无需将其挂载到你的操作系统上，也不需要一个文件系统。

再把刚写入的数据取出来，你可以看到驱动器上的原始数据：

```
# head -n 1 /dev/sdx
hello world
```

这看起来工作得很好，但是想象一下如果 “hello world” 这个短语是一个文件，如果你想要用这种方法写入一个新的文件，则必须：

  1. 知道第 1 行已经存在一个文件了
  2. 知道已经存在的文件只占用了 1 行
  3. 创建一种新的方法来在后面添加数据，或者在写第 2 行的时候重写第 1 行

例如：

```
# echo 'hello world
> this is a second file' >> /dev/sdx
```

获取第 1 个文件，没有任何改变。

```
# head -n 1 /dev/sdx
hello world
```

但是，获取第 2 个文件的时候就显得有点复杂了。

```
# head -n 2 /dev/sdx | tail -n 1
this is a second file
```

显然，通过这种方式读写数据并不实用，因此，开发人员创建了一个系统来跟踪文件的组成，并标识一个文件的开始和结束，等等。

大多数的文件系统都需要一个分区。

### 创建分区

分区是硬盘驱动器的一种边界，用来告诉文件系统它可以占用哪些空间。举例来说，你有一个 4GB 的 USB 驱动器，你可以只分一个分区占用一个驱动器 （4GB），或两个分区，每个 2GB (又或者是一个 1GB，一个 3GB，只要你愿意)，或者三个不同的尺寸大小，等等。这种组合将是无穷无尽的。

假设你的驱动器是 4GB，你可以使用 GNU `parted` 命令来创建一个大的分区。

```
# parted /dev/sdx --align opt mklabel msdos 0 4G
```

按 `parted` 命令的要求，首先指定了驱动器的路径。

`--align` 选项让 `parted` 命令自动选择一个最佳的开始点和结束点。

`mklabel` 命令在驱动器上创建了一个分区表 （称为磁盘卷标）。这个例子使用了 msdos 磁盘卷标，因为它是一个非常兼容和流行的卷标，虽然 gpt 正变得越来越普遍。

最后定义了分区所需的起点和终点。因为使用了 `--align opt` 标志，所以 `parted` 将根据需要调整大小以优化驱动器的性能，但这些数字仍然可以做为参考。

接下来，创建实际的分区。如果你开始点和结束点的选择并不是最优的， `parted` 会向您发出警告并让您做出调整。

```
# parted /dev/sdx -a opt mkpart primary 0 4G

Warning: The resulting partition is not properly aligned for best performance: 1s % 2048s != 0s
Ignore/Cancel? C                                                          
# parted /dev/sdx -a opt mkpart primary 2048s 4G
```

如果你再次运行 `lsblk` 命令，（你可能必须要拔掉驱动器，并把它再插回去），你就可以看到你的驱动器上现在已经有一个分区了。

### 手动创建一个文件系统

我们有很多文件系统可以使用。有些是开源和免费的，另外的一些并不是。一些公司拒绝支持开源文件系统，所以他们的用户无法使用开源的文件系统读取，而开源的用户也无法在不对其进行逆向工程的情况下从封闭的文件系统中读取。

尽管有这种特殊的情况存在，还是仍然有很多文件系统可以使用，选择哪个取决于驱动器的用途。如果你希望你的驱动器兼容多个系统，那么你唯一的选择是 exFAT 文件系统。然而微软尚未向任何开源内核提交 exFAT 的代码，因此你可能必须在软件包管理器中安装 exFAT 支持，但是 Windows 和 MacOS 都支持 exFAT 文件系统。

一旦你安装了 exFAT 支持，你可以在驱动器上你创建好的分区中创建一个 exFAT 文件系统。

```
# mkfs.exfat -n myExFatDrive /dev/sdx1
```

现在你的驱动器可由封闭系统和其它开源的系统（尚未经过微软批准）内核模块进行读写了。

Linux 中常见的文件系统是 [ext4][1]。但对于便携式的设备来说，这可能是一个麻烦的文件系统，因为它保留了用户的权限，这些权限通常因为计算机而异，但是它通常是一个可靠而灵活的文件系统。只要你熟悉管理权限，那 ext4 对于便携式的设备来说就是一个很棒的文件系统。

```
# mkfs.ext4 -L myExt4Drive /dev/sdx1
```

拔掉你的驱动器，再把它插回去。对于 ext4 文件系统的便携设备来说，使用 `sudo` 创建一个目录，并将该目录的权限授予用户和系统中通用的组。如果你不确定使用哪个用户和组，也可以使用 `sudo` 或 `root` 来修改出现问题的设备的读写权限。

### 使用桌面工具

很高兴知道了在只有一个 Linux shell 的时候如何操作和处理你的块设备，但是，有时候你仅仅是想让一个驱动器可用，而不需要进行那么多的检测。 GNOME 的 KDE 的开发者们提供了这样的一些优秀的工具让这个过程变得简单。

[GNOME 磁盘][2] 和 [KDE 分区管理器][3] 是一个图形化的工具，为本文到目前为止提到的一切提供了一个一体化的解决方案。启动其中的任何一个，来查看所有连接的设备（在左侧列表中），创建和调整分区大小，和创建文件系统。

![KDE 分区管理器][5]

*KDE 分区管理器*

可以预见的是，GNOME 版本会比 KDE 版本更加简单，因此，我将使用复杂的版本进行演示——如果你愿意动手的话，很容易弄清楚 GNOME 磁盘工具的使用。

启动 KDE 分区管理工具，然后输入你的 root 密码。

在最左边的一列，选择你想要格式化的驱动器。如果你的驱动器并没有列出来，确认下是否已经插好，然后选择 “Tools > Refresh devices” （或使用键盘上的 F5 键）。

除非你想销毁驱动器已经存在的分区表，否则请勿继续。选择好驱动器后，单击顶部工具栏中的 “New Partition Table” 。系统会提示你为该分区选择一种卷标：gpt 或 msdos 。前者更加灵活可以处理更大的驱动器，而后者像很多微软的技术一样，是占据大量市场份额的事实上的标准。

现在您有了一个新的分区表，在右侧的面板中右键单击你的设备，然后选择 “New” 来创建新的分区，按照提示设置分区的类型和大小。此操作包括了分区步骤和创建文件系统。

![创建一个新分区][7]

*创建一个新分区*

要将更改应用于你的驱动器，单击窗口左上角的 “Apply” 按钮。

### 硬盘驱动器，轻松驱动

在 Linux 上处理硬盘驱动器很容易，甚至如果你理解硬盘驱动器的语言就更容易了。自从切换到 Linux 系统以来，我已经能够以任何我想要的方式来处理我的硬盘驱动器了。由于 Linux 在处理存储提供的透明性，因此恢复数据也变得更加容易了。

如果你想实验并了解有关硬盘驱动器的更多的信息，请参考下面的几个提示：

  1. 备份您的数据，而不仅仅是你在实验的驱动器上。仅仅需要一个小小的错误操作来破坏一个重要驱动器的分区。（这是一个用来学习重建丢失分区的很好的方法，但并不是很有趣）。
  2. 反复确认你所定位的驱动器是正确的驱动器。我经常使用 `lsblk` 来确定我并没有移动驱动器。（因为从两个独立的 USB 端口移除两个驱动器很容易，然后以不同的顺序重新连接它们，就会很容易导致它们获得了新的驱动器标签。）
  3. 花点时间“销毁”你测试的驱动器，看看你是否可以把数据恢复。在删除文件系统后，重新创建分区表或尝试恢复数据是一个很好的学习体验。

还有一些更好玩的东西，如果你身边有一个封闭的操作系统，在上面尝试使用一个开源的文件系统。有一些项目致力于解决这种兼容性，并且尝试让它们以一种可靠稳定的方式工作是一个很好的业余项目。

--------------------------------------------------------------------------------

via: https://opensource.com/article/18/11/partition-format-drive-linux

作者：[Seth Kenlon][a]
选题：[lujun9972][b]
译者：[Jamskr](https://github.com/Jamskr)
校对：[wxy](https://github.com/wxy)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]: https://opensource.com/users/seth
[b]: https://github.com/lujun9972
[1]: https://opensource.com/article/17/5/introduction-ext4-filesystem
[2]: https://wiki.gnome.org/Apps/Disks
[3]: https://www.kde.org/applications/system/kdepartitionmanager/
[4]: /file/413586
[5]: https://opensource.com/sites/default/files/uploads/blockdevices_kdepartition.jpeg (KDE Partition Manager)
[6]: /file/413591
[7]: https://opensource.com/sites/default/files/uploads/blockdevices_newpartition.jpeg (Create a new partition)
