开发和部署的不同
============================================================
 ![The difference between development and deployment](https://opensource.com/sites/default/files/styles/image-full-size/public/images/business/BUS_OpenSourceExperience_520x292_cm.png?itok=APna2N9Y "The difference between development and deployment") 
图片提供 : 

opensource.com

多年来，我是一名 Smalltalk 程序员，这种经验给让我在观察编程世界时有不同的想法。例如，源代码应该存储在文本文件中的想法需要一些习惯。

我们作为程序员通常区分“开发”和“部署”，特别是我们在一个地方开发使用的工具不同于我们之后部署软件时的地点和工具。在Smalltalk世界里，没有这样的区别。

Smalltalk 构建于虚拟机包含了你的开发环境（IDE、调试器、文本编辑器、版本控制等）的想法上，如果你必须修改任何代码，你将修改内存中运行副本。如果你想快照运行中的机器，你可以这样做，如果你想分发你的代码，你可以发送一个运行的机器镜像（包括IDE、调试器、文本编辑器、版本控制等）的副本到用户。这就是 90 年代软件开发的工作原理（对我们中的一些人来说）。

如今部署环境与开发环境有了很大的不同。对于初学者，你不希望那里有任何开发工具。一旦部署，就没有版本控制、没有调试、没有开发环境。有记录和监视，这些在我们的开发环境中没有，并且有一个“构建管道”，它将我们的软件从我们开发形式转换为部署形式。例如，Docker 容器试图重新抓住 1990 年代 Smalltalk 程序员部署经验的一些简单性，而不希望对开发体验做同样的事情。

我想如果 Smalltalk 世界是我唯一的编程隐喻体验，无法区分开发和部署环境，我可能作为侥幸回顾一下它。但在我是一名 Smalltalk 程序员之前，我是一位 APL 程序员，这也是一个可以修改虚拟机镜像的世界，其中开发和部署是无法区分的。因此，我相信，当前的世界，人们编辑单独的源代码文件，然后运行构建管道以e创建在编辑代码时不存在的部署工作，然后将这些作品部署到用户。我们已经以某种方式将这种反模式软件开发制度化，并且不断发展的软件环境的需求正在迫使我们找到回到 20  世纪 90 年代更有效的技术的方法。因此会有 Docker 的成功。因此，我需要提出建议。

我有两个建议：我们在运行时系统中实现（和使用）版本控制，我们通过更改运行系统来开发软件，而不是用新的运行系统替换它们。这两个想法是相关的。为了安全地更改正在运行的系统，我们需要一些版本控制功能来支持“撤消”功能。也许公平地说，我只提出一个建议。让我举例来说明。

让我们开始想象一个静态网站。你要修改一些 HTML 文件。你应该如何工作？如果你像大多数开发者一样，你会有两个，也许三个网站 - 一个用于开发，一个用于QA（或者预发布），一个用于生产。你将直接编辑开发实例中的文件。准备就绪后，你将“部署”你的修改到预发布实例。在用户验收测试之后，你将再次部署，这次是生产环境。

使用 Occam 的 Razor，让我们避免不必要地创建实例。我们需要多少台机器？我们可以使用一台电脑。我们需要多少台网络服务器？我们可以使用具有多个虚拟主机的单台 web 服务器，而不是多个虚拟主机，我们可以使用单台虚拟主机吗？然后，我们需要多个目录，并需要使用 URL 的顶级路径来区分不同的版本，而不是虚拟主机名。但是为什么我们需要多个目录？因为 web 服务器将从文件系统中提供静态文件。我们的问题是，目录有三个不同的版本，我们的解决方案是创建目录的三个不同的副本。这不是像 Subversion 和 Git 这样的版本控制系统解决的问题？制作目录的多个副本以存储多个版本的策略回到了 CVS 之前的日子。为什么不使用，也就是一个空的的 Git 仓库来存储文件？因为要这样做，web 服务器将需要能够从 git 仓库读取文件（参见[mod_git] [3]）。

这将是一个支持版本控制的运行时系统。

使用这样的 web 服务器，使用的版本可以由 cookie 来标识。这样，任何人都可以推送到仓库，用户将继续看到他们发起会话时分配的版本。版本控制系统有不可改变的提交; 一旦会话开始，开发人员可以在不影响正在运行的用户的情况下快速推送更改。开发人员可以重置其会话以跟踪他们的新提交，因此开发人员或测试人员就可能如普通用户一样查看在同台服务器上同一个URL上正在开发或正在测试的版本。作为偶然的副作用，A/B 测试仅仅是将不同的用户分配给不同的提交的情况。所有用于管理多个版本的 git 设施都在运行环境中发挥作用。当然，git reset 为我们提供了前面提到的“撤销”功能。

为什么不是每个人都这样做？

一种可能性是，诸如版本控制系统的工具不被设计为在生产环境中使用。例如，给某人许可推送到测试分支而不是生产分支是不可能的。对这个方案最常见的反对是，如果发现了一个漏洞，你会想要将某些提交标记为不可访问。这将是另一种更细粒度的权限的情况;开发人员将具有对所有提交的读取权限，但外部用户不会。我们可能需要对现有工具进行一些额外的工作以支持这种模式，但是这些功能很容易理解，并已被设计到其他软件中。例如，Linux （或 PostgreSQL）实现了对不同用户的细粒度权限的想法。

随着云环境变得越来越普及，这些想法变得更加相关：云总是在运行。例如，我们可以看到，AWS 中等价的 “文件系统”（S3）实现了版本控制，所以你可能有一个不同的想法，使用一台 web 服务器提供来自 S3 的资产，并使用会话信息选择不同版本的资产。重要的想法并不是实现是最好的，而是支持运行时版本控制的愿望。

部署的软件环境应该是“版本感知”的原则扩展到除了服务静态资产的web服务器之外的其他工具。在将来的文章中，我将介绍版本库，数据库和应用程序服务器的方法。

_在 linux.conf.au 中了解更多 Robert Lefkowitz 2017 年 （[＃lca2017][1]）在 Hobart：[保持 Linux 伟大][2]的主题。_

--------------------------------------------------------------------------------

作者简介： 

![](https://opensource.com/sites/default/files/styles/profile_pictures/public/pictures/robert_lefkowitz.jpg?itok=CFoX-OUI)

Robert M. Lefkowitz - Robert（a / k / a r0ml）是一个喜欢复杂编程语言的编程语言爱好者。 他是一个提高清晰度、提高可靠性和最大限度地简化编程技术的收藏家。他通过让计算机更加容易获得来使它普及化。他经常演讲中世纪晚期和早期文艺复兴对编程艺术的影响。

--------------------------------------------------------------------------------

via: https://opensource.com/article/17/1/difference-between-development-deployment

作者：[Robert M. Lefkowitz][a]
译者：[geekpi](https://github.com/geekpi)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]:https://opensource.com/users/r0ml
[1]:https://twitter.com/search?q=%23lca2017&src=typd
[2]:https://www.linux.conf.au/schedule/presentation/107/
[3]:https://github.com/r0ml/mod_git
