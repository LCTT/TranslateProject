怎样去查找并杀掉非法的MySQL查询
================================================================================
有时,相关数据库系统的复杂性可能被压倒.幸运地,这种复杂性是一种优势,与 MySQL工具一起管理查询. 在本教程中, 我将向你们展示 **怎样去查找并杀掉任何非法的MySQL查询**.

为了浏览当前正在运行的查询, 登陆到MySQL终端，然后运行‘show processlist’命令:

    mysql> show processlist; 

    +--------+--------+-----------------+---------+---------+-------+-------+------------------+-----------+---------------+-----------+
    | Id     | User   | Host            | db      | Command | Time  | State | Info             | Rows_sent | Rows_examined | Rows_read |
    +--------+--------+-----------------+---------+---------+-------+-------+------------------+-----------+---------------+-----------+
    |  78233 | root   | 127.0.0.1:37527 | mysql   | Sleep   | 16474 |       | NULL             |         6 |             6 |         6 |
    |  84546 | root   | 127.0.0.1:48593 | mysql   | Sleep   | 13237 |       | NULL             |         2 |             2 |         2 |
    | 107083 | root   | 127.0.0.1:56451 | mysql   | Sleep   | 15488 |       | NULL             |         1 |           121 |       121 |
    | 131455 | root   | 127.0.0.1:48550 | NULL    | Query   |     0 | NULL  | show processlist |         0 |             0 |         0 |
    +--------+--------+-----------------+---------+---------+-------+-------+------------------+-----------+---------------+-----------+
    4 rows in set (0.03 sec)

首先 你应该查看'Time'项, 这里记录了进程执行 "doing the thing it's doing" 操作的秒数. ‘command’项处于‘Sleep’
状态的进程正在等待查询, 因此,它并没有消耗任何资源. 对于其他任何进程而言，‘Time’超过一定的秒数表明出现问题.

在这种情况下,只能通过运行‘show processlist’命令来查询.如果我们有一个糟糕的写查询，让我们来看看情况如何:

    mysql> show processlist; 

    +--------+--------+-----------------+-----------+---------+-------+--------------+----------------------------------+-----------+---------------+-----------+
    | Id     | User   | Host            | db        | Command | Time  | State        | Info                             | Rows_sent | Rows_examined | Rows_read |
    +--------+--------+-----------------+-----------+---------+-------+--------------+----------------------------------+-----------+---------------+-----------+
    |  78233 | root   | 127.0.0.1:37527 | example   | Sleep   | 18046 |              | NULL                             |         6 |             6 |         6 |
    |  84546 | root   | 127.0.0.1:48593 | example   | Sleep   | 14809 |              | NULL                             |         2 |             2 |         2 |
    | 107083 | root   | 127.0.0.1:56451 | example   | Sleep   | 17060 |              | NULL                             |         1 |           121 |       121 |
    | 132033 | root   | 127.0.0.1:54642 | example   | Query   |    27 | Sending data | select max(subtotal) from orders |         0 |             0 |         0 |
    | 133933 | root   | 127.0.0.1:48679 | NULL      | Query   |     0 | NULL         | show processlist                 |         0 |             0 |         0 |
    | 134122 | root   | 127.0.0.1:49264 | example   | Sleep   |     0 |              | NULL                             |         0 |             0 |         0 |
    +--------+--------+-----------------+-----------+---------+-------+--------------+----------------------------------+-----------+---------------+-----------+
    6 rows in set (0.00 sec)

啊哈！现在我们看到这里的查询几乎运行了30s. 如果我们不想让它继续运行，可以使用它的'Id'去执行kill命令:

    mysql> kill 132033;
    Query OK, 0 rows affected (0.00 sec)
    mysql> 

(注意 由于我们没有改变任何数据,MySQL总是报告0行被影响.)

明智的使用kill命令能够清除积压的查询.记住,但那不是一种永久的方法 - 如果这些查询来自你的应用,你需要去重写它们,或者将继续看到相同的问题.

### 另请参阅 ###

关于不同‘Command’的MySQL文档:

- [https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html][1]

--------------------------------------------------------------------------------

via: http://xmodulo.com/2014/07/find-kill-misbehaving-mysql-queries.html

译者：[hunanchenxingyu](https://github.com/hunanchenxingyu) 校对：[校对者ID](https://github.com/校对者ID)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创翻译，[Linux中国](http://linux.cn/) 荣誉推出

[1]:https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html