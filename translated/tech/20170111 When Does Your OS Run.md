[你的操作系统什么时候运行？][1]
============================================================

这里有一个问题：在你读到这句话时，你的操作系统在运行吗？或者它只运行一个浏览器？或者可能它们都处于空闭状态，或者是时刻准备着为你服务？

这些问题都很简单，但是他们都直中要害，涉及到软件是如何工作的本质所在。要准确回答这些问题，我们需要一个操作系统行为的心智模型，它揭示了相应的性能、安全、以及排错决策。我们将在这篇文章中使用 Linux 作为主要的操作系统，同时客串 OS X 和 Windows 来构建一个这样的模型。并为想去深度探索这些问题的人提供了 Linux 内核源代码的链接。

这里的基本原理是，在任何一个给定时刻，在 CPU 上只有一个任务处于活动状态。这个任务一般是一个程序，就像你的浏览器或者音乐播放器，或者也可能是一个操作系统线程，但是只有一个任务，而不是两个或者更多，也不会是零个。**任何时候**它只有**一个任务**在 CPU 上运行。

播放声音似乎是个麻烦，为什么这么说呢？你的音乐播放程序独占着 CPU，并且不让其它程序运行？因此你也不可能打开一个工具去终止它的运行，甚至鼠标点击也会失败，因为操作系统不能去处理它们。你可能会被卡住“这个狐狸在说什么？”并且引发工作混乱（译者注：《the fox》挪威乐队Ylvis单曲）。

这个时候就需要**中断**了。就像大脑的神经系统中断带来了外部的刺激 —— 一个刺耳的噪声，一个肩膀上的触摸 —— 计算机主板中的 [芯片][2] 中断 CPU 去传递外部事件消息 —— 键按下、网络包到达、硬盘读完成等等。外设硬件、主板上的中断控制器、以及 CPU 自身，三者协同工作去实现这些中断，简称**中断**。

在跟踪的过程中，中断也是必不可少的，它保存了我们最重要的东西：时间。在内核程序的 [引导过程][3] 中，一个硬件定时器在一个周期性的间隔中发出**定时器中断**，例如，每 10 毫秒一次。当定时器激活时，内核获得一个 CPU  时隙去更新系统统计数据和盘点事物：当前程序是否运行时间过长？是否发生 TCP 传输超时？中断给内核一个机会去考虑这些问题并做出合适的动作。就像是你设置了一个周期性的闹钟，然后将它作为一个检查点：我现在做的这些事情是否正确？还有没有比它更紧迫的事情？有一天你发现已经过去了十年。

CPU 被内核周期性的劫持称为**滴答**（ticks），因此，中断让你的操作系统正常运行起来。还不止这些：中断还被用于去处理一些软件事件，像整数溢出和页面故障，它们都不需要外部硬件。**中断非常频繁并且是操作系统内核的入口**。对于计算机工程专业的人来说，这并不是什么奇怪的事，它是让你的操作系统正常运行的机制。

说了这么多，我们现在来看一下一些动作。下图是一个 Intel Core i5 系统上的网卡。这个示意图中的图片内置链接，因此，你可以点击它获取更多信息。例如，每个设备都链接到它的 Linux 驱动上。

![](https://manybutfinite.com/img/os/hardware-interrupt.png)

我们来看一下这张图。首先，因为有许多的中断源，如果只是硬件简单地告诉 CPU，"CPU 你好，发生了一些事情！“然后转身离开，这样是没有什么用处的。而挂起也是无法让人接受的。因此，在计算机的电源开关打开后，每个设备都分配了一个中断请求线，或者称为 IRQ。这些 IRQ 被中断控制器映射到一个中断向量，它是一个 0 到 255 的数字。这样当一个中断到达 CPU 时，它就有一个很好的、预定义的、与变幻无常的硬件无关的数字。

CPU 有一个指向到内核提供的有 255 个函数的数组上的指针，数组中的每个函数用于去处理特定的中断向量。接下来，我们将看到这个数组——中断描述表（IDT），后面将描述它的更多细节。

无论什么时候，当出现一个中断时，CPU 使用它的向量作为索引进入 IDT，然后去运行相关的句柄。这时候在当前运行任务的上下文中会发生特定的函数调用，允许操作系统以最小的开销去快速响应外部事件。因此，当它们要给你发送数据时，web 服务器将间接地在你的 CPU 中调用一个函数，这要么很酷要么很可怕。下图展示了在 CPU 很繁忙的运行着一个 Vim 命令的时候出现了一个中断的情形：

![](https://manybutfinite.com/img/os/vim-interrupted.png)

注意为什么中断出现时会导致切换到内核模式和 [ring 0][4]但是却没有改变活动的任务。它就好象 Vim 产生了一个神奇的函数调用，直接进入到内核，但是 Vim 却一直在那里，它的 [地址空间][5] 完好无损，等待这个调用返回。

这太神奇了！由于我需要控制文章的长度，因此，现在我要结束本文了。我知道我留了一个未回答的问题，事实上是开启了一个新的问题，但是你现在猜测到当你在读这句话时滴答正在发生。在充实我们的动态操作系统行为模型之后，我们就会找到答案，并且浏览场景也将变得更清晰。如果你有任何问题，尤其是因为这篇文章产生的问题，欢迎提问，我将在这个主题的后续文章中或者以评论的方式回复你。下一篇将发表在明天的 [RSS][6] 和 [Twitter][7] 上。

--------------------------------------------------------------------------------

via:https://manybutfinite.com/post/when-does-your-os-run/

作者：[Gustavo Duarte][a]
译者：[qhwdw](https://github.com/qhwdw)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出

[a]:https://manybutfinite.com/about/
[1]:https://manybutfinite.com/post/when-does-your-os-run/
[2]:https://manybutfinite.com/post/motherboard-chipsets-memory-map
[3]:https://manybutfinite.com/post/kernel-boot-process
[4]:https://manybutfinite.com/post/cpu-rings-privilege-and-protection
[5]:https://manybutfinite.com/post/anatomy-of-a-program-in-memory
[6]:https://manybutfinite.com/feed.xml
[7]:http://twitter.com/manybutfinite